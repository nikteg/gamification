<!DOCTYPE html>
<html>
<head>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.16/d3.min.js" charset="utf-8"></script>
	<script src="gaussian/lib/gaussian.js"></script>

	<meta charset="utf-8">
	<title>Graph experiment</title>
</head>
	<body>
		<div id="line"></div>
		 <script>
			//Initialization
			var exp = 10,
			variance = 5;
			var distribution = gaussian(exp,variance);

			//Visuals
			var height = 300,
				heightOffset = 30;
				width = 500,
				widthOffset = 40;
				
			//Data values	
			var	n = 1000,
				xstep = 1,
				leastValueX = 0;
				
			//TODO: Still buggy with small exp values.__
			var	realxrange = exp*3,
				usedxrange = exp*2;
			//__________________________________________
			
			//Colors, graph specific elements
			var	graphBGColor = "#eee",
				graphLineColor = "#ff7f0e",
				axisColor = "steelblue",
				markerColor = "steelblue";
				
			//Colors, other elements
			var circleColor = "crimson",
				coordinateTextColor = "crimson",
				cumulativeTextColor = "crimson",
				cursorColor = "white";
				graphAreaColor = "#ffbb78";

			//Append svg element to body
			var svg = d3.select("body").append("svg:svg")
				.style("background", graphBGColor)
				.attr("height", height+heightOffset)
				.attr("width", width+widthOffset*2);
			
			//Initialize data
			var data = d3.range(realxrange-1).map(function(){return 0});
			
			for(var i = 0; i < n; i++){
				var sample = Math.round(distribution.ppf(Math.random()));
				data[sample] += 1;
			}
			
			//Scale 
			scalex = d3.scale.linear().domain([leastValueX,usedxrange]).range([widthOffset,width+widthOffset]);
			scaley = d3.scale.linear().domain([d3.max(data),0]).range([heightOffset,height-heightOffset]);
			
			//Scale from data to item size
			xRange = d3.scale.linear().domain([leastValueX,usedxrange]).range([widthOffset,width+widthOffset]);
			yRange = d3.scale.linear().domain([d3.max(data),0]).range([0,height-heightOffset]);
			
			//Scale from item size to data
			scaleAxisX = d3.scale.linear().domain([0,width]).range([leastValueX,usedxrange]);
			scaleAxisY = d3.scale.linear().domain([heightOffset,height]).range([0,d3.max(data)]);

			//Add area gradient
			 var areaGradient = svg.append("linearGradient");	
				areaGradient
					.attr("id", "area-gradient")			
					.attr("gradientUnits", "userSpaceOnUse")	
					.attr("x1", 0).attr("y1", 0)			
					.attr("x2", 1).attr("y2", 0)		
				.selectAll("stop")						
					.data([								
						{offset: "99.9%", color: graphAreaColor},		
						{offset: "100%", color: "#eee"},	
												])						
				.enter().append("stop")			
					.attr("offset", function(d) { return d.offset; })	
					.attr("stop-color", function(d) { return d.color; });			 
	
			//Area
			var areaSVG = d3.svg.area()
				.interpolate("cardinal")
				.x(function(d,i) {return scalex(i); })
				.y0(height)
				.y1(function(d){return scaley(d); });
				
			var area = svg.append("path").attr("d", areaSVG(data))
				.attr("fill", "url(#area-gradient)");

			
			//Axis
			//X
			var xAxis = d3.svg.axis().scale(xRange).orient("bottom").ticks(10);
			var xax = svg.append("g")
				.attr("class", "axis")
				.attr("transform", "translate(0, "+ (height)+")")
				.call(xAxis);

			xax.select("path")
				.attr("fill", "none")
				.attr("stroke", axisColor)
				.attr("shape-rendering", "crispEdges");

			xax.selectAll("text")
				.attr("fill",axisColor)
				.attr("font-size", "10px");

			//Y
			var yAxis = d3.svg.axis().scale(yRange).orient("left").ticks(10);
			var yax = svg.append("g")
				.attr("class", "axis")
				.attr("transform", "translate("+ widthOffset+", "+heightOffset+")")
				.call(yAxis);

			yax.select("path")
				.attr("fill", "none")
				.attr("stroke", axisColor)
				.attr("shape-rendering", "crispEdges");

			yax.selectAll("text")
				.attr("fill",axisColor)
				.attr("font-size", "10px");

			//Line
			var line = d3.svg.line()
				.interpolate("cardinal")
				.x(function(d,i) {return scalex(i)})
				.y(function(d){return scaley(d)});
			
			var straightLine = d3.svg.line()
				.interpolate("cardinal")
				.x(function(d,i){return scalex(i)})
				.y(function(){return height-20});
				
				
			//Path
			var path = svg.append("svg:path")
				.attr("d", straightLine(data))
				.attr("fill", "none")
				.attr("stroke", graphLineColor)
				.transition()
				.attr("d", line(data))
				.duration(700)
				.delay(500);
				
				
			//Cumulative marker
			var cumulativeMarker = svg.append("svg:line")
				.attr("stroke", markerColor)
				.attr("stroke-width", 1)
				.attr("x1", width+50)
				.attr("x2", width+50)
				.attr("y1", 0)
				.attr("y2", height)
				.attr("opacity", 0);

			//Big tick line, shows mean
			var tickline = svg.append("svg:line")
				.attr("stroke", axisColor)
				.attr("stroke-width", 3)
				.attr("x1", xRange(distribution.mean))
				.attr("x2", xRange(distribution.mean))
				.attr("y1", height+5)
				.attr("y2", height-5);

			//Horizontal Line
			var horLine = svg.append("svg:line")
				.attr("stroke", cursorColor)
				.attr("stroke-width", 1)
				.attr("x1", 0)
				.attr("x2", width)
				.attr("y1", height)
				.attr("y2", height)
				.attr("opacity", 0);	
			
			//Vertical Line
			var vertLine = svg.append("svg:line")
				.attr("stroke", cursorColor)
				.attr("stroke-width", 1)
				.attr("x1", width+50)
				.attr("x2", width+50)
				.attr("y1", 0)
				.attr("y2", height)
				.attr("opacity", 0);

			//Coordinate text
			var coordinateText =
				svg.append("text")
				.attr("fill", coordinateTextColor)
				.attr("font-size", "8px");
			
			//Cumulative distribution
			var cumulativeText =
				svg.append("text")
				.attr("fill", cumulativeTextColor)
				.attr("font-size", "10px")
				.attr("opacity", 0);

			//Circle
			var circle =
				svg.append("circle")
				.attr("cx", 100)
				.attr("cy", 350)
				.attr("r", 3)
				.attr("fill", circleColor);

			//Path
			var pathEl = path.node();
			var pathLength = pathEl.getTotalLength();
			//---What is BBox?
			var BBox = pathEl.getBBox();
			var scale = pathLength/BBox.width;

			var offsetLeft = document.getElementById("line").offsetLeft;
					
			
			//Button
				//Skip

			//Mousemove
			svg.on("mousemove", function(){
				//var x = d3.event.pageX - offsetLeft;
				var coordinates = [0,0];
				coordinates = d3.mouse(this);
				var x = coordinates[0];

				var beginning = x-widthOffset,
					end = pathLength,
					target;

				//Calculate position of circle
				while(true){
					target = Math.floor((beginning+end)/2);
					pos = pathEl.getPointAtLength(target);
					if((target === end) || target === beginning && pos.x !== x){
						break;
					}
					if(pos.x > x)		end = target;
					else if(pos.x < x) 	beginning = target;
					else				break;
				}
				//Actions during mousemove
				circle
					.attr("opacity", 1)
					.attr("cx", x)
					.attr("cy", pos.y);

				vertLine
					.attr("x1", x)
					.attr("x2", x)

				horLine
					.attr("y1", Math.round(pos.y))
					.attr("y2", Math.round(pos.y));

				coordinateText
					.attr("x", x-23)
					.attr("y", pos.y - 7)
					.text("("+(scaleAxisX(x-widthOffset)).toFixed(2) + ", " + (d3.max(data)-(scaleAxisY((pos.y)))).toFixed(2)+")");

			});

			//Mouseclick
			svg.on("click", function(){
				var x = vertLine.attr("x2"); 
				var target = scaleAxisX(x-widthOffset);
				var cumulativeValue = distribution.cdf(target);
				
				cumulativeText
					.attr("x", ((vertLine.attr("x2") - widthOffset)/2)-10)
					.attr("y", height - 15)
					.attr("opacity", 1)
					.text("P(X < "+ target.toFixed(2) +") = "+(cumulativeValue*100).toFixed(2) + "%");
				
				cumulativeMarker
					.attr("x1", x)
					.attr("x2", x)
					.attr("y1", horLine.attr("y1"))
					.attr("y2", height)
					.attr("opacity", 1)	
					.attr("stroke", "white");
					
				cumulativeMarker
					.transition()
					.delay(350)
					.attr("stroke", graphLineColor)
					.duration(100)
					;
				
				areaGradient
					.transition()	
					.attr("x1", 0 ).attr("y1", 0)			
					.attr("x2", vertLine.attr("x1")).attr("y2", 0)
					.duration(450);
					;

					
			});
			
		</script>
	</body>
</html>